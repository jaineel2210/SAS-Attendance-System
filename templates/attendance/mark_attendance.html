{% extends "base.html" %}

{% block title %}Mark Attendance - SecureAttend Pro{% endblock %}

{% block content %}
<div class="container mt-4">
    <div class="row">
        <div class="col-lg-8 mx-auto">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h4 class="mb-0"><i class="fas fa-camera me-2"></i>Mark Your Attendance</h4>
                </div>
                <div class="card-body">
                    <!-- Current Period Info -->
                    <div id="currentPeriodInfo" class="alert alert-info mb-4" style="display: none;">
                        <h6><i class="fas fa-clock me-2"></i>Current Period Information</h6>
                        <div id="periodDetails"></div>
                    </div>
                    
                    <!-- Today's Schedule -->
                    <div id="todaySchedule" class="mb-4">
                        <h6><i class="fas fa-calendar-day me-2"></i>Today's Schedule</h6>
                        <div id="scheduleList" class="small">Loading schedule...</div>
                    </div>
                    
                    <div class="text-center mb-4">
                        <p class="lead">Choose your preferred method to mark attendance:</p>
                    </div>

                    <!-- Face Recognition Option -->
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <div class="card border-info">
                                <div class="card-body text-center">
                                    <i class="fas fa-face-smile fa-3x text-info mb-3"></i>
                                    <h5>Face Recognition</h5>
                                    <p class="text-muted">Use your camera to mark attendance</p>
                                    <button class="btn btn-info" id="startCameraBtn">
                                        Start Camera
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- RFID Option -->
                        <div class="col-md-6 mb-3">
                            <div class="card border-success">
                                <div class="card-body text-center">
                                    <i class="fas fa-id-card fa-3x text-success mb-3"></i>
                                    <h5>RFID Card</h5>
                                    <p class="text-muted">Tap your RFID card</p>
                                    <button class="btn btn-success" id="startRFIDBtn">
                                        Scan Card
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Video/Camera Container -->
                    <div id="cameraContainer" class="text-center mt-4" style="display: none;">
                        <div class="card">
                            <div class="card-body">
                                <video id="video" width="640" height="480" autoplay style="border-radius: 8px;"></video>
                                <canvas id="canvas" width="640" height="480" style="display: none;"></canvas>
                                <div class="mt-3">
                                    <button id="captureBtn" class="btn btn-primary me-2">
                                        <i class="fas fa-camera me-1"></i>Capture
                                    </button>
                                    <button id="stopBtn" class="btn btn-secondary">
                                        <i class="fas fa-stop me-1"></i>Stop
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- RFID Input Container -->
                    <div id="rfidContainer" class="text-center mt-4" style="display: none;">
                        <div class="card">
                            <div class="card-body">
                                <h5>Place your RFID card near the reader</h5>
                                <div class="spinner-border text-success mt-3" role="status">
                                    <span class="visually-hidden">Reading...</span>
                                </div>
                                <p class="mt-2">Waiting for card...</p>
                                <button id="rfidCancelBtn" class="btn btn-secondary mt-3">Cancel</button>

                                <!-- For testing purposes -->
                                <div class="mt-3">
                                    <input type="text" id="rfidInput" class="form-control"
                                        placeholder="Enter RFID UID (for testing)" maxlength="16">
                                    <button id="simulateRFIDBtn" class="btn btn-success mt-2">Simulate RFID</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Status Messages -->
                    <div id="statusMessage" class="alert" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Global variables
    let stream = null;
    let isProcessing = false;

    // Debug logging function
    function debug(message, data = null) {
        console.log(`[Attendance System] ${message}`, data || '');
    }

    // Ensure status message element exists
    function ensureStatusMessageElement() {
        debug('Ensuring status message element exists');
        let statusElement = document.getElementById('statusMessage');
        if (!statusElement) {
            statusElement = document.createElement('div');
            statusElement.id = 'statusMessage';
            statusElement.className = 'alert';
            statusElement.style.display = 'none';
            
            // Find the card-body to append to
            const cardBody = document.querySelector('.card-body');
            if (cardBody) {
                cardBody.appendChild(statusElement);
            } else {
                console.error('Could not find .card-body to append status message to');
            }
        }
        return statusElement;
    }

    // Initialize event listeners when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        debug('Initializing attendance system...');
        
        // Load today's schedule
        loadTodaySchedule();
        
        // Ensure status message element exists
        ensureStatusMessageElement();
        
        // Direct button initialization
        const startCameraBtn = document.getElementById('startCameraBtn');
        const startRFIDBtn = document.getElementById('startRFIDBtn');
        const captureBtn = document.getElementById('captureBtn');
        const stopBtn = document.getElementById('stopBtn');
        const rfidCancelBtn = document.getElementById('rfidCancelBtn');
        const simulateRFIDBtn = document.getElementById('simulateRFIDBtn');

        debug('Found buttons:', {
            startCamera: !!startCameraBtn,
            startRFID: !!startRFIDBtn,
            capture: !!captureBtn,
            stop: !!stopBtn,
            rfidCancel: !!rfidCancelBtn,
            simulateRFID: !!simulateRFIDBtn
        });

        // Add event listeners directly
        if (startCameraBtn) {
            startCameraBtn.addEventListener('click', async () => {
                debug('Start camera button clicked');
                try {
                    await startFaceRecognition();
                } catch (error) {
                    debug('Error in startFaceRecognition:', error);
                    showStatus('Failed to start camera: ' + error.message, 'danger');
                }
            });
        }

        if (startRFIDBtn) {
            startRFIDBtn.addEventListener('click', () => {
                debug('Start RFID button clicked');
                try {
                    startRFIDReading();
                } catch (error) {
                    debug('Error in startRFIDReading:', error);
                    showStatus('Failed to start RFID reader: ' + error.message, 'danger');
                }
            });
        }

        if (captureBtn) {
            captureBtn.addEventListener('click', async () => {
                debug('Capture button clicked');
                try {
                    await handleCapture();
                } catch (error) {
                    debug('Error in handleCapture:', error);
                    showStatus('Failed to capture image: ' + error.message, 'danger');
                }
            });
        }

        if (stopBtn) {
            stopBtn.addEventListener('click', () => {
                debug('Stop button clicked');
                try {
                    stopCamera();
                } catch (error) {
                    debug('Error in stopCamera:', error);
                    showStatus('Failed to stop camera: ' + error.message, 'danger');
                }
            });
        }

        if (rfidCancelBtn) {
            rfidCancelBtn.addEventListener('click', () => {
                debug('RFID cancel button clicked');
                try {
                    stopRFIDReading();
                } catch (error) {
                    debug('Error in stopRFIDReading:', error);
                    showStatus('Failed to stop RFID reader: ' + error.message, 'danger');
                }
            });
        }

        if (simulateRFIDBtn) {
            simulateRFIDBtn.addEventListener('click', () => {
                debug('Simulate RFID button clicked');
                try {
                    simulateRFID();
                } catch (error) {
                    debug('Error in simulateRFID:', error);
                    showStatus('Failed to simulate RFID: ' + error.message, 'danger');
                }
            });
        }

        // Add event listeners with error handling
        const addSafeListener = (element, event, handler) => {
            if (element) {
                console.log(`Adding ${event} listener to ${element.id}`);
                element.addEventListener(event, async (e) => {
                    try {
                        await handler(e);
                    } catch (error) {
                        console.error(`Error in ${element.id} handler:`, error);
                        showStatus(`Error: ${error.message}`, 'danger');
                    }
                });
            } else {
                console.warn(`Button element not found: ${element}`);
            }
        };

        // Add listeners to all buttons
        addSafeListener(buttons.startCamera, 'click', startFaceRecognition);
        addSafeListener(buttons.startRFID, 'click', startRFIDReading);
        addSafeListener(buttons.capture, 'click', handleCapture);
        addSafeListener(buttons.stop, 'click', stopCamera);
        addSafeListener(buttons.rfidCancel, 'click', stopRFIDReading);
        addSafeListener(buttons.simulateRFID, 'click', simulateRFID);
    });

    // Function to assess image quality
    async function assessImageQuality(imageData) {
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                try {
                    // Get image data for analysis
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Calculate average brightness
                    let totalBrightness = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        totalBrightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    }
                    const avgBrightness = totalBrightness / (data.length / 4);

                    // Calculate face size relative to image
                    const faceWidth = canvas.width * 0.4; // Expecting face to be at least 40% of image width
                    const faceHeight = canvas.height * 0.4; // Expecting face to be at least 40% of image height
                    
                    // Score components (0-100 each)
                    const brightnessScore = avgBrightness < 50 ? avgBrightness * 2 : 
                                          avgBrightness > 200 ? (255 - avgBrightness) * 2 : 100;
                    const sizeScore = Math.min((canvas.width / faceWidth) * 100, 100);
                    
                    // Weighted average
                    const totalScore = (brightnessScore * 0.6) + (sizeScore * 0.4);
                    
                    resolve(totalScore);
                } catch (error) {
                    console.error('Error in image quality assessment:', error);
                    resolve(0);
                }
            };
            img.onerror = () => {
                console.error('Error loading image for quality assessment');
                resolve(0);
            };
            img.src = imageData;
        });
    }
    async function startFaceRecognition() {
        debug('Starting face recognition...');
        try {
            // First, stop any existing streams
            if (stream) {
                debug('Stopping existing stream');
                await stopCamera();
            }

            // Hide any existing error messages and reset UI
            const statusElement = document.getElementById('statusMessage');
            if (statusElement) {
                statusElement.style.display = 'none';
            }
            
            // Show camera container and hide RFID
            const cameraContainer = document.getElementById('cameraContainer');
            const rfidContainer = document.getElementById('rfidContainer');
            
            if (!cameraContainer) {
                throw new Error('Camera container not found in DOM');
            }
            
            cameraContainer.style.display = 'block';
            if (rfidContainer) {
                rfidContainer.style.display = 'none';
            }

            const video = document.getElementById('video');
            if (!video) {
                throw new Error('Video element not found');
            }
            
            console.log('Requesting camera access...');
            // Request camera access with specific constraints
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    width: { ideal: 640 },
                    height: { ideal: 480 },
                    facingMode: 'user' // prefer front camera
                } 
            });
            
            video.srcObject = stream;
            
            console.log('Camera stream obtained, waiting for video to load...');
            // Wait for video to be ready
            await new Promise((resolve) => {
                video.onloadedmetadata = resolve;
            });
            
            // Start playing video
            await video.play();
            console.log('Video playback started');

            showStatus('Camera started. Position your face in the frame and click capture.', 'info');
        } catch (error) {
            console.error('Error in startFaceRecognition:', error);
            showStatus('Error accessing camera: ' + error.message, 'danger');
        }
    }

    async function handleCapture() {
        if (isProcessing) {
            console.log('Already processing a capture...');
            return;
        }

        console.log('Starting capture process...');
        const captureBtn = document.getElementById('captureBtn');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        
        isProcessing = true;

        try {
            // Validate camera and canvas
            if (!video || !canvas) {
                throw new Error('Camera not properly initialized. Please refresh the page and try again.');
            }

            // Ensure video is playing and has dimensions
            if (!video.videoWidth || !video.videoHeight || video.paused || video.ended) {
                console.log('Video state:', {
                    width: video.videoWidth,
                    height: video.videoHeight,
                    paused: video.paused,
                    ended: video.ended
                });
                throw new Error('Camera not ready. Please wait a moment and try again.');
            }

            // Disable capture button
            if (captureBtn) {
                captureBtn.disabled = true;
            }

            showStatus('Preparing to capture...', 'info');
            
            // Give user time to prepare
            await new Promise(resolve => setTimeout(resolve, 1000));
            showStatus('Hold still...', 'info');
            
            // Take the capture
            console.log('Taking capture...');
            const capture = await takeSingleCapture(video, canvas);
            
            // Process the capture
            console.log('Processing capture...');
            showStatus('Processing image...', 'info');
            
            // Send to server for processing
            console.log('Sending to server...');
            const response = await processAttendance('face', { image_data: capture });
            
            if (response && response.success) {
                showStatus('Attendance marked successfully!', 'success');
                // Optional: Show success animation
                const successOverlay = document.createElement('div');
                successOverlay.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-success bg-opacity-75';
                successOverlay.innerHTML = `
                    <div class="text-white text-center">
                        <i class="fas fa-check-circle fa-3x mb-3"></i>
                        <h4>Attendance Marked!</h4>
                    </div>
                `;
                document.body.appendChild(successOverlay);
                setTimeout(() => successOverlay.remove(), 2000);
            } else {
                throw new Error(response.message || 'Failed to process attendance');
            }

        } catch (error) {
            console.error('Capture error:', error);
            showStatus(error.message || 'Failed to capture image', 'danger');
        } finally {
            // Re-enable capture button
            if (captureBtn) {
                captureBtn.disabled = false;
            }
            isProcessing = false;
        }
    }

    async function takeSingleCapture(video, canvas) {
        return new Promise((resolve, reject) => {
            try {
                const context = canvas.getContext('2d');
                if (!context) {
                    throw new Error('Could not get canvas context');
                }

                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Draw the current video frame
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Convert to base64
                const imageData = canvas.toDataURL('image/jpeg', 0.9);
                resolve(imageData);
            } catch (error) {
                console.error('Error in takeSingleCapture:', error);
                reject(new Error('Failed to capture image from camera'));
            }
        });
    }
    async function takeSingleCapture(video, canvas) {
        const context = canvas.getContext('2d');
        if (!context) throw new Error('Could not get canvas context');

        // Clear canvas
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw video frame to canvas
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Get image data
        return canvas.toDataURL('image/jpeg', 0.9);
    }
    
    async function assessImageQuality(imageDataUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            
            img.onload = () => {
                // Create temporary canvas for analysis
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                try {
                    // Get image data for analysis
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Calculate average brightness
                    let totalBrightness = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        totalBrightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    }
                    const avgBrightness = totalBrightness / (data.length / 4);
                    
                    // Calculate contrast (standard deviation of brightness)
                    let variance = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        const pixelBrightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        variance += Math.pow(pixelBrightness - avgBrightness, 2);
                    }
                    const contrast = Math.sqrt(variance / (data.length / 4));
                    
                    // Detect edges using a simple gradient
                    let edges = 0;
                    const width = canvas.width;
                    for (let y = 1; y < canvas.height - 1; y++) {
                        for (let x = 1; x < width - 1; x++) {
                            const idx = (y * width + x) * 4;
                            const dx = Math.abs(data[idx] - data[idx + 4]);
                            const dy = Math.abs(data[idx] - data[idx + width * 4]);
                            edges += (dx + dy) / 2;
                        }
                    }
                    const edgeScore = edges / (canvas.width * canvas.height);
                    
                    // Calculate final quality score (0-100)
                    let score = 0;
                    
                    // Brightness score (prefer values between 100-200)
                    const brightnessScore = Math.max(0, 100 - Math.abs(avgBrightness - 150) / 1.5);
                    
                    // Contrast score (higher is better, up to a point)
                    const contrastScore = Math.min(100, contrast / 2);
                    
                    // Edge score (indicates face features)
                    const edgeScoreNormalized = Math.min(100, edgeScore / 10);
                    
                    // Weighted average
                    score = (brightnessScore * 0.3) + (contrastScore * 0.3) + (edgeScoreNormalized * 0.4);
                    
                    resolve(score);
                } catch (error) {
                    console.error('Error analyzing image:', error);
                    resolve(0); // Return 0 for failed analysis
                }
            };
            
            img.onerror = () => {
                console.error('Error loading image for analysis');
                resolve(0);
            };
            
            img.src = imageDataUrl;
        });
    }
        
    

    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        document.getElementById('cameraContainer').style.display = 'none';
    }

    function startRFIDReading() {
        console.log('Starting RFID reading...');
        const rfidContainer = document.getElementById('rfidContainer');
        const cameraContainer = document.getElementById('cameraContainer');
        
        if (rfidContainer && cameraContainer) {
            rfidContainer.style.display = 'block';
            cameraContainer.style.display = 'none';
            
            // Stop camera if it's running
            if (stream) {
                stopCamera();
            }
            
            // Clear any previous RFID input
            const rfidInput = document.getElementById('rfidInput');
            if (rfidInput) {
                rfidInput.value = '';
            }
            
            showStatus('RFID reader activated. Place your card near the reader.', 'info');
        } else {
            console.error('RFID or Camera container elements not found');
            showStatus('Error initializing RFID reader', 'danger');
        }
    }

    function stopRFIDReading() {
        console.log('Stopping RFID reading...');
        const rfidContainer = document.getElementById('rfidContainer');
        if (rfidContainer) {
            rfidContainer.style.display = 'none';
        }
        showStatus('RFID reader deactivated', 'info');
    }

    function simulateRFID() {
        const rfidInput = document.getElementById('rfidInput');
        const rfidUID = rfidInput.value.trim();

        if (!rfidUID) {
            showStatus('Please enter an RFID UID', 'warning');
            return;
        }

        processAttendance('rfid', { rfid_uid: rfidUID });
    }

    async function processAttendance(method, data) {
        if (isProcessing && method !== 'face') {
            console.log('Already processing attendance...');
            return;
        }

        console.log('Processing attendance...', { method });
        showStatus('Processing attendance...', 'info');

        try {
            // Log the data being sent (without the actual image data for brevity)
            console.log('Sending attendance data:', {
                method,
                timestamp: new Date().getTime(),
                imageSize: data.image_data ? data.image_data.length : 'N/A'
            });

            const response = await fetch('/mark_student_attendance', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: JSON.stringify({
                    method,
                    ...data,
                    timestamp: new Date().getTime()
                })
            });

            // Log the response status
            console.log('Server response status:', response.status);

            if (!response.ok) {
                const errorText = await response.text();
                console.error('Server error response:', errorText);
                throw new Error(`Server error: ${response.status} - ${errorText || response.statusText}`);
            }

            const result = await response.json();
            console.log('Server response:', result);

            if (result.success) {
                const message = `Attendance marked successfully for ${result.student_name}`;
                const subjectInfo = result.subject ? ` - ${result.subject} (Period ${result.period})` : '';
                const fullMessage = message + subjectInfo;
                
                showStatus(fullMessage, 'success');
                console.log('Attendance marked successfully');
                
                // Create a success overlay
                const overlay = document.createElement('div');
                overlay.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center';
                overlay.style.cssText = 'background-color: rgba(0,0,0,0.7); z-index: 1050;';
                
                const content = document.createElement('div');
                content.className = 'text-center p-4 bg-white rounded shadow';
                content.innerHTML = `
                    <i class="fas fa-check-circle text-success fa-3x mb-3"></i>
                    <h4>Attendance Marked Successfully!</h4>
                    <div class="mb-2"><strong>Student:</strong> ${result.student_name}</div>
                    <div class="mb-2"><strong>Enrollment:</strong> ${result.enrollment_no}</div>
                    ${result.subject ? `<div class="mb-2"><strong>Subject:</strong> ${result.subject}</div>` : ''}
                    ${result.period ? `<div class="mb-2"><strong>Period:</strong> ${result.period}</div>` : ''}
                    ${result.session_type ? `<div class="mb-3"><span class="badge bg-primary">${result.session_type.toUpperCase()}</span></div>` : ''}
                    <div class="small text-muted mb-3">You may now close this window</div>
                    <button class="btn btn-primary" id="closeSuccessDialog">Close Window</button>
                `;
                
                overlay.appendChild(content);
                document.body.appendChild(overlay);
                
                // Add click event to close button
                const closeBtn = overlay.querySelector('#closeSuccessDialog');
                closeBtn.addEventListener('click', function() {
                    overlay.remove();
                    // Reset the form
                    stopCamera();
                    stopRFIDReading();
                    if (document.getElementById('rfidInput')) {
                        document.getElementById('rfidInput').value = '';
                    }
                    // Reload schedule to update attendance status
                    loadTodaySchedule();
                });
                
                // Reset forms after success
                setTimeout(() => {
                    stopCamera();
                    stopRFIDReading();
                    if (document.getElementById('rfidInput')) {
                        document.getElementById('rfidInput').value = '';
                    }
                    // Refresh schedule to show updated status
                    loadTodaySchedule();
                }, 1000);
                
                return result;
            } else {
                console.error('Server response:', result);
                throw new Error(result.message || 'Server reported an error');
            }
        } catch (error) {
            console.error('Error in processAttendance:', error);
            
            let errorMessage = error.message;
            // If it's a JSON parsing error or network error, provide a more user-friendly message
            if (error instanceof SyntaxError || error.name === 'TypeError') {
                errorMessage = 'Network error or invalid server response. Please try again.';
            }
            
            // Provide specific feedback based on error type
            if (error.message.toLowerCase().includes('quality')) {
                showStatus('Please ensure good lighting and face the camera directly', 'warning');
            } else if (error.message.toLowerCase().includes('multiple faces')) {
                showStatus('Please ensure only your face is visible in the camera', 'warning');
            } else if (error.message.toLowerCase().includes('no face')) {
                showStatus('No face detected. Please position yourself in front of the camera', 'warning');
            } else if (error.message.toLowerCase().includes('not recognized')) {
                showStatus('Face not recognized. Please ensure you are registered in the system', 'warning');
            } else {
                showStatus('Error: ' + error.message, 'danger');
            }
            
            throw error;
        } finally {
            isProcessing = false;
            const captureBtn = document.getElementById('captureBtn');
            if (captureBtn) captureBtn.disabled = false;
        }
    }

    function showStatus(message, type) {
        const statusElement = ensureStatusMessageElement();
        statusElement.className = `alert alert-${type}`;
        statusElement.textContent = message;
        statusElement.style.display = 'block';

        // Auto-hide after 5 seconds for non-error messages
        if (type !== 'danger') {
            setTimeout(() => {
                if (document.getElementById('statusMessage')) {
                    statusElement.style.display = 'none';
                }
            }, 5000);
        }
    }

    // Cleanup when leaving page
    window.addEventListener('beforeunload', () => {
        stopCamera();
    });

    // Load today's schedule and current period information
    async function loadTodaySchedule() {
        try {
            const response = await fetch('/get_student_schedule');
            const data = await response.json();
            
            if (data.success) {
                displaySchedule(data.schedule, data.current_period, data.current_day);
            } else {
                document.getElementById('scheduleList').textContent = data.message || 'Failed to load schedule';
            }
        } catch (error) {
            console.error('Error loading schedule:', error);
            document.getElementById('scheduleList').textContent = 'Error loading schedule';
        }
    }

    function displaySchedule(schedule, currentPeriod, currentDay) {
        const scheduleList = document.getElementById('scheduleList');
        const currentPeriodInfo = document.getElementById('currentPeriodInfo');
        const periodDetails = document.getElementById('periodDetails');
        
        if (!schedule || schedule.length === 0) {
            scheduleList.innerHTML = `<div class="text-muted">No classes scheduled for ${currentDay}</div>`;
            return;
        }
        
        // Display current period info
        if (currentPeriod) {
            currentPeriodInfo.style.display = 'block';
            periodDetails.innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <strong>Period ${currentPeriod.period_number}:</strong> ${currentPeriod.subject}
                    </div>
                    <div class="col-md-6">
                        <strong>Time:</strong> ${currentPeriod.start_time_str} - ${currentPeriod.end_time_str}
                    </div>
                </div>
                <div class="mt-2">
                    <span class="badge bg-primary">${currentPeriod.session_type.toUpperCase()}</span>
                    ${currentPeriod.marked ? '<span class="badge bg-success ms-2">Attendance Marked</span>' : '<span class="badge bg-warning ms-2">Attendance Pending</span>'}
                </div>
            `;
        }
        
        // Display complete schedule
        let scheduleHtml = `<div class="row g-2">`;
        
        schedule.forEach(period => {
            const statusBadge = period.marked ? 
                '<span class="badge bg-success">âœ“ Marked</span>' : 
                '<span class="badge bg-secondary">Pending</span>';
            
            const isCurrentClass = currentPeriod && currentPeriod.period_number === period.period_number;
            const cardClass = isCurrentClass ? 'border-primary bg-light' : '';
            
            scheduleHtml += `
                <div class="col-md-6 col-lg-4">
                    <div class="card ${cardClass} h-100">
                        <div class="card-body p-2">
                            <div class="d-flex justify-content-between align-items-start">
                                <div>
                                    <h6 class="card-title mb-1">Period ${period.period_number}</h6>
                                    <p class="card-text small mb-1">${period.subject}</p>
                                    <p class="card-text small text-muted">${period.start_time_str} - ${period.end_time_str}</p>
                                    <span class="badge bg-info">${period.session_type}</span>
                                </div>
                                <div>
                                    ${statusBadge}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        });
        
        scheduleHtml += `</div>`;
        scheduleList.innerHTML = scheduleHtml;
    }
</script>
{% endblock %}